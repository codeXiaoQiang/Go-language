package main

import "fmt"

func main() {
	/*
	1.无论是C语言中的数组还是Go语言中的数组,数组的长度一旦确定就不能改变, 但在实际开发中我们可能事先不能确定数组的长度, 为了解决这类问题Go语言中推出了一种新的数据类型切片
	2.什么是切片?
	切片简单理解就是一个可变长度的数组
	底层的实现原理就是一个结构体, 结构体中有一个指针指向了一个数组
	本质上所有的数据都是保存在指向的数组中的
	type slice struct{
	  array unsafe.Pointer // 指向底层数组指针
	  len int // 切片长度(保存了多少个元素)
	  cap int // 切片容量(可以保存多少个元素)
	}
	3.如何创建切片
	3.1通过数组来创建
	格式: [起始位置:结束位置], 从起始位置开始截取, 直到结束位置, 但是不包括结束位置
	注意:  截取了多少个元素, len就等于几
	       容量等于数组的长度 - 起始位置
	3.2通过make函数来创建
	格式: make([]数据类型, 长度, 容量)

	3.3通过Go提供的语法糖来创建

	注意点:
	只要数组的[]中没有编写数字, 那么这个就不是一个数组, 这就是一个切片
	 */

	// 1.通过数组来创建
	/*
	// 1.创建一个数组
	//				  		   0  1  2  3  4
	var ages [5]int = [5]int{1, 3, 5, 7, 9}
	// 2.通过数组创建切片
	// [起始位置:结束位置], 从起始位置开始截取, 直到结束位置, 但是不包括结束位置
	//var sce []int = ages[0:2]
	//var sce []int = ages[2:4]
	// 注意点: 如果只写了起始位置, 没有写结束位置, 那么会截取到最后
	//var sce []int = ages[0:]
	//var sce []int = ages[2:]
	// 注意点: 如果只写了结束位置, 没有写开始位置, 那么会从开始截取到指定的结束位置
	//var sce []int = ages[:2]
	// 注意点: 如果只写了:, 那么就是从开始截取到末尾
	var sce []int = ages[:]
	fmt.Println(sce)
	// 计算切片当前保存数据的个数
	fmt.Println(len(sce))
	// 计算切片总共可以保存数据的个数
	fmt.Println(cap(sce))
	*/

	// 2.通过make函数创建切片
	/*
	// 第一个参数: 告诉系统要存储什么类型的数据
	// 注意点: 如果是创建切片一定要在传入的数据类型前面写上[]
	// 第二个参数: 告诉系统创建出来的切片len等于多少
	// 第三个参数: 告诉系统创建出来的切片cap等于多少
	// 注意点: 第三个参数可以省略, 如果省略切片的容量就等于切片的长度(等于第二个参数)
	//var sce []int = make([]int, 2, 5)
	var sce []int = make([]int, 2)
	fmt.Println(sce)
	fmt.Println(len(sce))
	fmt.Println(cap(sce))
	*/

	// 3.通过Go提供的语法糖来创建
	// 一定要注意[]里面没有值就是切片
	// 通过Go提供的语法糖来创建len等于cap
	var sce []int = []int{1, 3, 5} // 相当于make([]int, 3)
	fmt.Println(sce)
	fmt.Println(len(sce))
	fmt.Println(cap(sce))
}
